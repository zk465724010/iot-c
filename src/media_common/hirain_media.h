/**
 *   File: hirain_media.h & hirain_media.cpp
 *  Usage: Streaming media processing
 * Author: zk
 *   Date: 2022.8.11
 */
#ifndef __HIRAIN_MEDIA_H__
#define __HIRAIN_MEDIA_H__

#include <stdio.h>
#include "Thread11.h"
#include "minio.h"

#ifdef __cplusplus
extern "C" {
#endif
#include "libavutil/mem.h"  // av_free()
#ifdef __cplusplus
};
#endif

#define BUFF_SIZE  1048576       // 1M

 ///////////////////////////////////////////////////////////////////////////////////////////
 // 2022.3.21 zk
typedef struct tag_stream_param {
    // Input
    const char* in_url = NULL;     // 输入URL(如:rtsp,本地文件路径等)
    int (*read_packet)(void* opaque, uint8_t* buf, int buf_size) = NULL;// 自定义输入回调
    int64_t (*seek_packet)(void* opaque, int64_t offset, int whence) = NULL;
    void* in_opaque = NULL;
    int64_t start_time = 0;         // 录像起始时间(播放本地录像文件时有效)
    float* ratio = NULL;            // 播放倍率,回放时有效 (共享变量)
    /// /////////////////////////////
    // Output
    const char* out_url = NULL;    // 输出文件名称
    int (*write_packet)(void* opaque, uint8_t* buf, int buf_size) = NULL;// 自定义输出回调
    void* out_opaque = NULL;
    // test
    const char* chl = NULL;         // 通道ID
}stream_param_t;

typedef struct IOContext {
    int64_t pos = 0;        // 当前位置
    int64_t filesize = 0;   // 文件大小
    uint8_t* fuzz = NULL;   // 数据起始指针
    int64_t fuzz_size = 0;   // 剩余数据大小
    const char* remote_name = NULL;
    bool enable = true;
} IOContext;
typedef struct stream_buffer
{
    unsigned char* buffer = NULL;
    int64_t buf_size = 1024 * 1024 * 16;  // 16M
    unsigned char* pos = NULL;
    unsigned char* limit = NULL;
    int write_size = 0;
    bool video_head = false;    // 是否是视频头帧
    bool reconnet = false;      // 是否是断流重连后的视频头帧
    ~stream_buffer() {
        if (NULL != buffer)
            av_free(buffer);
    }
} stream_buffer_t;

typedef int(*img_data_cbk)(void* opaque, uint8_t* buf, int buf_size);

enum media_error_code {
    NO_ERRORS = 0,            //无错误
    ERROR_ARG,              //参数错误
    ERROR_OPEN_URL_FAIL,    //打开rtsp url 失败
    ERROR_OPEN_FILE_FAIL,   //打开分片文件失败
    ERROR_STREAM_INFO_FAIL,//分析流信息失败
    ERROR_OPEN_OUTSTREAM_FAIL,//打开输出失败
    ERROR_CREATE_AVSTREAM_FAIL,//创建输出流失败
    ERROR_WRITE_PKT_FAIL,   //写包失败
    ERROR_NO_VIDEO_STREAM,  //没有视频流
    ERROR_SEEK_FAIL,        //拖动失败
    ERROR_READ_FRAME_FAIL,  //读包失败
    ERROR_MEM_FAIL,         //内存分配错误
    ERROR_IOCONTENT_FAIL,   //创建输出IO失败
    ERROR_FIND_CODE_FAIL,   //查找编码格式失败
    ERROR_CREATE_CODECOTENT_FAIL, //分配编码上下文失败
    ERROR_OPEN_CODE_FAIL,  //打开解码失败
    ERROR_DECODE_PACKET_FAIL,//解码失败
    ERROR_ENCODE_PACKET_FAIL,//编码失败
    VIDEO_ONLY,             //只有视频流
    VIDEO_AND_AUDIO,        //音视频一起
    FILE_EOF                //文件结束
};


int media_init(minio_info_t *cfg);
void media_release();

int media_video_to_image(stream_param_t* params);
int image_write_packet(void* opaque, uint8_t* buf, int buf_size);

int media_video_stream(char* control_cmd, stream_param_t* params);

int media_read_packet(void* opaque, uint8_t* buf, int buf_size);
int media_write_packet(void* opaque, unsigned char* buf, int buf_size);
int64_t media_seek_packet(void* opaque, int64_t offset, int whence);
void STDCALL media_download_thdproc(STATE& state, PAUSE& p, void* pUserData);
int STDCALL media_minio_callback(void* data, size_t size, void* arg);
int media_create_object_cbk(void*& obj, int& obj_size, void* user_data);
void media_destory_object_cbk(void*& obj, void* user_data);
int media_interrupt_cbk(void* opaque);

#endif